import { create } from 'xmlbuilder2';
import { annotationFromObject } from "./../Annotation";
import { PublicationGreekWordElement } from "./PublicationGreekWordElement";
import { HasReferenceString, PublicationHebrewWordElement } from "./PublicationHebrewWordElement";
import { WordElementCreator, PublicationVerse } from "./PublicationVerse";
import { PublicationRequest } from "./../PublicationRequest";
import { UbsBook, Canon, VerseReference } from "./../VerseReference";
import { BookHopper } from "./../ProjectDump";

export interface BookDumpJson {
    book_id: UbsBook;
    canon: Canon;
    book_title: string;
    rows: any[];
}

export class PublicationBook {
    readonly book_id: UbsBook;
    readonly canon: Canon;
    readonly book_title: string;
    readonly hopper: BookHopper;
    private rows: any[];

    constructor(json: BookDumpJson) {
        this.book_id = json.book_id;
        this.canon = json.canon;
        this.book_title = json.book_title;
        this.rows = json.rows;

        /// convert the annotation JSON to objects
        json.rows = json.rows.map((row: any) => {
            if (row.gloss !== null) {
                row.gloss = annotationFromObject(row.gloss);
            }
            return row;
        });

        this.hopper = PublicationBook.putIntoHoppers(json.rows);
    }

    toTEI(request: PublicationRequest): string {
        let content = "";
        switch (this.canon) {
            case 'OT':
                content = PublicationBook.processRowsToXml(this, request, PublicationHebrewWordElement.fromWordRow);
                break;
            case 'NT':
                content = PublicationBook.processRowsToXml(this, request, PublicationGreekWordElement.fromWordRow);
                break;
            default:
                throw new Error('Invalid canon');
        }
        return content;
    }

    toJsonObject(): BookDumpJson {
        return {
            book_id: this.book_id,
            canon: this.canon,
            book_title: this.book_title,
            rows: this.rows
        }
    }

    static processRowsToXml(
        book: PublicationBook,
        request: PublicationRequest,
        objectCreator: WordElementCreator
    ): string {
        const currentDate = new Date();
        const publicationStmt = `Generated by openreadersbibles.org at ${currentDate.toISOString()}`;

        let biblicalLanguageIso;
        if (book.canon == "OT") {
            biblicalLanguageIso = "hbo";
        } else {
            biblicalLanguageIso = "grc";
        }

        const doc = create({ version: '1.0', encoding: 'UTF-8' })
            .ele('TEI', { version: '3.3.0', xmlns: 'http://www.tei-c.org/ns/1.0', "xmlns:orb": "https://openreadersbibles.org/" })
            .att('orb:layout-direction', request.project.layout_direction)
            .ele('teiHeader')
            .ele('fileDesc')
            .ele('titleStmt')
            .ele('title').txt(book.book_title).up()
            .up()
            .ele('publicationStmt')
            .ele('p').txt(publicationStmt).up()
            .up()
            .up()
            .ele('profileDesc')
            .ele('langUsage')
            .ele('language', { ident: biblicalLanguageIso, scope: "major" }).up()
            .up()
            .up()
            .up()
            .ele('text')
            .ele('body');

        book.hopper.forEach((chapter: any[], chapterIndex: number) => {
            const plainChapterNumber = request.project.replaceNumerals((chapterIndex + 1).toString());
            const footnoteChapterHeader = request.project.getChapterHeader(chapterIndex + 1);

            const chapter_node = doc.ele('div', { type: 'chapter', n: chapterIndex + 1 });

            chapter.forEach((verse: any[]) => {
                let reference = VerseReference.fromString(verse[0].reference);
                if (reference) {
                    const v = PublicationVerse.fromWordElements(verse, reference, request, objectCreator);
                    const verse_node = chapter_node.ele('div', { type: 'verse', n: reference.verse });
                    v.verseXml(verse_node);
                }
            });
        });

        return doc.end({ prettyPrint: false });
    }


    static putIntoHoppers(rows: HasReferenceString[]): BookHopper {
        let hopper: BookHopper = [];
        let currentChapter = 0;
        let currentVerse = 0;
        for (let i = 0; i < rows.length; i++) {
            let row = rows[i];
            let reference = VerseReference.fromString(row.reference);
            if (reference) {
                /// if we've hit a new chapter create a new section
                if (reference.chapter !== currentChapter) {
                    /// create a new chapter
                    hopper.push([]);
                    /// create a new verse
                    hopper[hopper.length - 1].push([]);
                    currentChapter = reference.chapter;
                    currentVerse = 1;
                } else if (reference.verse !== currentVerse) {
                    /// create a new verse
                    hopper[hopper.length - 1].push([]);
                    currentVerse = reference.verse;
                }
                let chapter = hopper[hopper.length - 1];
                let verse = chapter[chapter.length - 1];
                verse.push(row);
            } else {
                console.error('Error parsing reference: ' + reference);
            }
        }
        return hopper;
    }

}